package database

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"math"
	"os"
	"strconv"
	"strings"
	"time"

	_ "github.com/joho/godotenv/autoload"
	"github.com/redis/go-redis/v9"
)

type Service interface {
	Health() map[string]string
}

type service struct {
	db *redis.Client
}

var (
	address  = os.Getenv("DB_ADDRESS")
	port     = os.Getenv("DB_PORT")
	password = os.Getenv("DB_PASSWORD")
	database = os.Getenv("DB_DATABASE")
)

func New() Service {
	num, err := strconv.Atoi(database)
	if err != nil {
		log.Fatalf(fmt.Sprintf("database incorrect %v", err))
	}

	fullAddress := fmt.Sprintf("%s:%s", address, port)

	rdb := redis.NewClient(&redis.Options{
		Addr:     fullAddress,
		Password: password,
		DB:       num,
		TLSConfig: &tls.Config{
			MinVersion: tls.VersionTLS12,
		},
	})

	s := &service{db: rdb}

	return s
}

// Health returns the health status and statistics of the Redis server.
func (s *service) Health() map[string]string {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	// Ping the Redis server to check its availability.
	result, err := s.db.Ping(ctx).Result()

	if err != nil {
		log.Fatalf(fmt.Sprintf("db down: %v", err))
	}

	// Check if the ping response is unexpected.
	if result != "PONG" {
		log.Fatalf(fmt.Sprintf("Unexpected ping response: %s", result))
	}

	// Retrieve Redis server information.
	info, err := s.db.Info(ctx).Result()
	if err != nil {
		return map[string]string{
			"redis_status":  "up",
			"redis_message": fmt.Sprintf("Failed to retrieve Redis info: %v", err),
		}
	}

	// Parse the Redis info response.
	redisInfo := parseRedisInfo(info)

	// Get the pool statistics of the Redis client.
	poolStats := s.db.PoolStats()

	// Prepare the stats map with Redis server information and pool statistics.
	stats := map[string]string{
		"redis_status":               "up",
		"redis_message":              "It's healthy",
		"redis_version":              redisInfo["redis_version"],
		"redis_mode":                 redisInfo["redis_mode"],
		"redis_connected_clients":    redisInfo["connected_clients"],
		"redis_used_memory":          redisInfo["used_memory"],
		"redis_used_memory_peak":     redisInfo["used_memory_peak"],
		"redis_uptime_in_seconds":    redisInfo["uptime_in_seconds"],
		"redis_hits_connections":     strconv.FormatUint(uint64(poolStats.Hits), 10),
		"redis_misses_connections":   strconv.FormatUint(uint64(poolStats.Misses), 10),
		"redis_timeouts_connections": strconv.FormatUint(uint64(poolStats.Timeouts), 10),
		"redis_total_connections":    strconv.FormatUint(uint64(poolStats.TotalConns), 10),
		"redis_idle_connections":     strconv.FormatUint(uint64(poolStats.IdleConns), 10),
		"redis_stale_connections":    strconv.FormatUint(uint64(poolStats.StaleConns), 10),
		"redis_max_memory":           redisInfo["maxmemory"],
	}

	// Calculate the number of active connections.
	// Note: We use math.Max to ensure that activeConns is always non-negative,
	// avoiding the need for an explicit check for negative values.
	// This prevents a potential underflow situation.
	activeConns := uint64(math.Max(float64(poolStats.TotalConns-poolStats.IdleConns), 0))
	stats["redis_active_connections"] = strconv.FormatUint(activeConns, 10)

	// Calculate the pool size percentage.
	poolSize := s.db.Options().PoolSize
	connectedClients, _ := strconv.Atoi(redisInfo["connected_clients"])
	poolSizePercentage := float64(connectedClients) / float64(poolSize) * 100
	stats["redis_pool_size_percentage"] = fmt.Sprintf("%.2f%%", poolSizePercentage)

	// Evaluate Redis stats and update the stats map with relevant messages.
	return s.evaluateRedisStats(redisInfo, stats)
}

// evaluateRedisStats evaluates the Redis server statistics and updates the stats map with relevant messages.
func (s *service) evaluateRedisStats(redisInfo, stats map[string]string) map[string]string {
	poolSize := s.db.Options().PoolSize
	poolStats := s.db.PoolStats()
	connectedClients, _ := strconv.Atoi(redisInfo["connected_clients"])
	highConnectionThreshold := int(float64(poolSize) * 0.8)

	// Check if the number of connected clients is high.
	if connectedClients > highConnectionThreshold {
		stats["redis_message"] = "Redis has a high number of connected clients"
	}

	// Check if the number of stale connections exceeds a threshold.
	minStaleConnectionsThreshold := 500
	if int(poolStats.StaleConns) > minStaleConnectionsThreshold {
		stats["redis_message"] = fmt.Sprintf("Redis has %d stale connections.", poolStats.StaleConns)
	}

	// Check if Redis is using a significant amount of memory.
	usedMemory, _ := strconv.ParseInt(redisInfo["used_memory"], 10, 64)
	maxMemory, _ := strconv.ParseInt(redisInfo["maxmemory"], 10, 64)
	if maxMemory > 0 {
		usedMemoryPercentage := float64(usedMemory) / float64(maxMemory) * 100
		if usedMemoryPercentage >= 90 {
			stats["redis_message"] = "Redis is using a significant amount of memory"
		}
	}

	// Check if Redis has been recently restarted.
	uptimeInSeconds, _ := strconv.ParseInt(redisInfo["uptime_in_seconds"], 10, 64)
	if uptimeInSeconds < 3600 {
		stats["redis_message"] = "Redis has been recently restarted"
	}

	// Check if the number of idle connections is high.
	idleConns := int(poolStats.IdleConns)
	highIdleConnectionThreshold := int(float64(poolSize) * 0.7)
	if idleConns > highIdleConnectionThreshold {
		stats["redis_message"] = "Redis has a high number of idle connections"
	}

	// Check if the connection pool utilization is high.
	poolUtilization := float64(poolStats.TotalConns-poolStats.IdleConns) / float64(poolSize) * 100
	highPoolUtilizationThreshold := 90.0
	if poolUtilization > highPoolUtilizationThreshold {
		stats["redis_message"] = "Redis connection pool utilization is high"
	}

	return stats
}

// parseRedisInfo parses the Redis info response and returns a map of key-value pairs.
func parseRedisInfo(info string) map[string]string {
	result := make(map[string]string)
	lines := strings.Split(info, "\r\n")
	for _, line := range lines {
		if strings.Contains(line, ":") {
			parts := strings.Split(line, ":")
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			result[key] = value
		}
	}
	return result
}
